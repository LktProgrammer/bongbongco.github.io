---
layout: post
title: 자바와 JSP의 기초.
categories: [Develpoment]
tags: [Development, Java, Job-Interview]
fullview: false
comments: true
published: true
---

자바
------
* 자바가상머신만 설치하면 운영체제와 관계 없이 동작하는 언어  
* 기본 자료형을 제외한 모든 요소를 객체로 표현하는 언어  
* 갭슐화, 상속, 다형성이 잘 적용된 언어  
* Garbage Collector를 이용한 자동 메모리 관리를 하는 언어  
* 멀티 쓰레드를 지원하는 언어  

객체지향
------
* 데이터를 객체로 취급하여 객체 간의 상호작용을 통해 프로그램이 동작하게 하는 설계 기법  
* 코드 재사용성이 높다.  
* 코드의 변경이 쉽다.  
* 코드 분석이 쉽다.  
* 객체지향 원칙을 사용하여(캡슐화, 상속, 다형성) 개발속도가 빨라진다.  

Object
------
* 객체는 객체지향프로그래밍에서 데이터와 그 데이터에 관련되는 동작, 모두가 포함되는 개념  

Overloading과 Overriding
------
* Overloading
	같은 이름의 메소드를 여러 개 정의	
	정의된 메소드의 매개변수는 타입이나 개수가 다름
	return type과 접근 제어자는 영향을 주지 않음
		
* Overriding
	관련 개념 : 상속
	상위 클래스의 메소드를 하위 클래스에서 재정의
	
Servlet, JSP
------
* Servlet : 자바를 이용하여 웹페이지를 동적으로 생성하는 서버 프로그램. (Container가 이해할 수 있게 구성된 순수 자바 코드로만 구성된 것)
* JSP : Html 내에 Java코드를 블럭화하여 삽입한 것

JDBC
------
Java Data Base Connection의 약자로 Java로 데이터베이스를 접근할 때 사용되는 표준 API.

GET, POST
------
* GET
	* 요청 인자 값을 주소 뒤에 붙여 보내므로 보안성이 떨어진다.
	* 조회에 목적을 둔다. (URL 자원 요청 - 요청을 수행해도 결과에 변화가 없음)
	* 글자수 제한
	* 브라우저에서 캐시할 수 있음(재 사용의 우려가 있음)
* POST
	* 요청 인자 값을 body 영역으로 보내므로 노출되지 않아 GET에 비해 보안성이 높다.
	* 조작에 목적을 둔다. (URL 자원 조작 요청 - 요청 수행 시 연산이 수행되고 상태가 변화할 수 있음)
	* 글자수 제한 없음

Session, Cookie
------
* Session과 Cookie가 필요한 이유
	* HTTP 프로토콜은 연결 지향적인 통신이 아니므로 페이지 이동 시 마다 새로운 접속이 이루어지며 이전 페이지와 현재 페이지 간의 관계가 지속되지 않는다. 이러한 문제를 해결하기 위해서 쿠키와 세션을 사용한다.
* Session
	* Session에 관련된 데이터는 Server에 저장된다.
	* 웹 브라우저의 캐시에 저장되어 브라우저가 닫히거나 서버에서 삭제 시 사라진다.
	* Cookie에 비해 보안성이 좋다.
	* 저장 데이터에 제한 없음

~~~ java
// 세션 설정 - 세션 속성값은 객체 형태
session.setAttribute("memId","test");
// 세션 가져오기 - 리턴 타입이 object이므로 String으로 변환
String id = (String)seesion.getAttribute("memId");
// 세션 속성의 이름을 반환
Enumeration names = session.getAttributeNames();
// 세션 삭제
session.removeAttribute("memId");
// 세션의 모든 속성 해제
session.invalidate();
// 세션의 최대 유지시간 설정(초단위 설정)
setMaxInactiveInterval(int interval);
// 세션의 최대 유지시간 반환
int sec = getMaxInactiveInterval();
~~~

* Cookie
	* Client PC에 저장되어 다른 사용자에 의한 임의 변경 위험이 있다.
	* 생성 이후 서버로 전송되는 요청에는 쿠키 정보가 같이 포함되어 전송
	* 이름, 값, 유효기간, 도메인, 경로 등으로 구성

~~~ java
// 생성
Cookie cooke = new Cookie(String name, String value);
// 쿠키 추가(생성후에 반드시 추가)
response.addCookie(cookie);
// 값을 수정
cookie.setValue(newValue);
// 읽기
// (1) 쿠키를 읽어 올 때
Cookie[] cookies = request.getCookies();
// (2) 쿠키 이름 읽기
String cookies[i].getName();
// (3) 쿠키 값읽기
String cookies[i].getValue();
// 쿠키의 수명(지속시간)
cookie.setMaxAge(int expiry);
~~~

MVC 패턴
------
* 사용자 인터페이스를 효과적으로 데이터 모형에 연결하기 위한 방법론
* Model: 데이터 베이스에 대응되는 데이터 구조
* View: 사용자 인터페이스 내 구성요소들을 표현
* Controller: Model과 View 클래스들 간 정보 교환

Interface, Abstract
------
* Interface
	* 일종의 추상 클래스
	* 오직 추상메서드와 상수만을 멤버로 갖는다.
	* Implements 키워드를 사용
	* 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록한다.
	* Extends는 하나의 클래스만 상속 가능하나 Interface는 다중 상속이 가능하다.

* Abstract
	* 추상메서드를 하나 이상 가진 클래스
	* 자신의 생성자로 객체 생성 불가능
	* 하위 클래스를 참조하여 상위 클래스의 객체를 생성
	* 하위 클래스를 제어하기 위해 사용

* Interface vs Abstract
	* 공통점 
		* new 연산자로 인스턴스 생성 불가능.
		* 프로토타입만 있는 메서드를 갖는다.
		* 사용하기 위해서는 하위클래스에서 확장/구현 해야 한다.
	* 차이점
		* 사용하는 키워드가 다르다.
		* Abstract는 일반 메서드를 사용할 수 있지만, Interface는 메서드 선언만 가능하다.

Call by Reference, Call by Value
------
* Call by Reference - 매개 변수의 원래 주소에 값을 저장하는 방식. 클래스 객체를 인수로 전달한 경우
* Call by Value - 인수로 기본 데이터형을 사용. 주어진 값을 복사하여 처리하는 방식. 메서드 내의 처리 결과는 메서드 밖의 변수에 영향을 미치지 않는다.

Static
------
* 클래스가 로딩될 때, 메모리 공간을 할당하는데 처음 설정된 메모리 공간이 변하지 않음을 의미
* 객체를 아무리 많이 만들어도 해당 변수는 하나만 존재(객체와 무관한 키워드)


Framework
------
* 특정 형태의 소프트웨어 문제를 해결하기 위해 상호 협력하는 클래스프레임과 인터페이스 프레임의 집합
* 특정한 틀을 만들어놓고 거기에 살을 붙여 놓음으로써 프로그램을 만들어 작업시간을 줄여주는 것이다. 
* 프레임워크는 특정 개념들의 추상화를 제공하는 여러 클래스나 컴포넌트로 구성된다.
* 프레임워크는 이렇게 추상적인 개념들이 문제를 해결하기 위해 같이 작업하는 방법을 정의한다.
* 프레임워크 컴포넌트 들은 재사용이 가능하다.
* 프레임워크는 좀 더 높은 수준에서 패턴을 조작한다.
* 프레임워크가 중요한 이유는 객체지향 개발을 하게 되면서 개발자의 취향에 따라 다양한 프로그램이 나오게 되었다. 프로그램 개발에 투입되는 개발자도 점점 늘어남에 따라 전체 시스템의 통합성, 일관성이 부족하게 되었기 때문이다. 그래서 개발자의 자유를 제한하기 위해 프레임워크를 도입했다.

* 프레임워크가 가져야할 특징
	* 개발자들이 따라야할 가이드라인을 가진다.
	* 개발할 수 있는 범위가 정해져 있다.
	* 개발자를 위한 다양한 도구들이 지원된다.

* 프레임워크의 장/단점
	* 장점 - 개발 시간을 줄일 수 있고 오류로부터 자유로울 수 있다.
	* 단점 - 프레임워크에 너무 의존하면 개발 능력이 떨어져서 프레임워크 없이 개발하는 것이 불가능해지는 점이다.

Garbage Collection
------
* 시스템에서 더이상 사용하지 않는 동적 할당된 메로리 블럭을 찾아 자동으로 다시 사용 가능한 자원으로 회수하는 것으로 시스템에서 가비지컬렉션을 수행하는 부분을 가비지 컬렉터라 부른다.

Primitive type, Reference type
------
* Primitive type - 변수에 값 자체를 저장 
	* 정수형 byte, short, int, long
	* 실수형 float, double
	* 문자형 char
	* 논리형 boolean
	* Primitive type은 Wrapper Class를 통해 객체로 변형할 수 있다.
		* 예) int→Integer, char→Character(int와 char를 제외한 Primitive type의 다른 자료형들은 맨 앞 알파벳을 대문자로 바꿔주면 된다. float→Float)

* Reference type - 메모리상에 객체가 있는 위치를 저장
	* 종류 - Class, Interface, Array 등


Wrapper Class
------
* Primitive type으로 표현할 수 있는 간단한 데이터를 객체로 만들어야 할 경우가 있는데 그러한 기능을 지원하는 클래스

Spring Framework
------
* 자바(JAVA) 플랫폼을 위한 오픈소스(Open Source) 애플리케이션 프레임워크(Framework)
* 자바 엔터프라이즈 개발을 편하게 해주는 오픈 소스 경량급 애플리케이션 프레임워크
* 자바 개발을 위한 프레임워크로 종속 객체를 생성해주고,  조립해주는 도구
* 자바로 된 프레임워크로 자바SE로 된 자바 객체(POJO)를 자바EE에 의존적이지 않게 연결해주는 역할

* 스프링 특징(간단히)
	* 크기와 부하의 측면에서 경량.
	* 제어 역행(IoC)이라는 기술을 통해 애플리케이션의 느슨한 결합을 도모
	* 관점지향 프로그래밍(AOP)을 위한 풍부한 지원
	* 애플리케이션 객체의 생명 주기와 설정을 포함하고 관리한다는 점에서 일종의 컨테이너(Container)라고 할 수 있음
	* 간단한 컴포넌트로 복잡한 애플리케이션을 구성하고 설정할 수 있음

* 스프링 특징 (자세히)
	* 경량 컨테이너로서 자바 객체를 직접 관리. 각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.
* 스프링은 POJO(Plain Old Java Object) 방식의 프레임워크.
   일반적인 J2EE 프레임워크에 비해 구현을 위해 특정한 인터페이스를 구현하거나 상속을 받을 필요가 없어 기존에 존재하는 라이브러리 등을 지원하기에 용이하고 객체가 가볍다.
* 스프링은 제어의 역행(IoC : Inversion of Control)을 지원.컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다.

* 스프링은 의존성 주입(DI : Dependency Injection)을 지원
   각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.

* 스프링은 관점 지향 프로그래밍(AOP : Aspect-Oriented Programming)을 지원
   따라서 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.

* 스프링은 영속성과 관련된 다양한 서비스를 지원
   iBatis나 Hibernate 등 이미 완성도가 높은 데이터베이스 처리 라이브러리와 연결할 수 있는 인터페이스를 제공한다.
   
*. 스프링은 확장성이 높음.
   스프링 프레임워크에 통합하기 위해 간단하게 기존 라이브러리를 감싸는 정도로 스프링에서 사용이 가능하기 때문에 수많은 라이브러리가 
   이미 스프링에서 지원되고 있고 스프링에서 사용되는 라이브러리를 별도로 분리하기도 용이하다.


Thread, Process
------
* Thread(쓰레드): 프로세스 내 독립적인 실행 단위
	* 빠른 프로세스 생성
	* 적은 메모리 사용
	* 쉬운 자원 공유
	* 교착 상태에 빠지기 쉬움(다중 프로그래밍 체제에서 하나 또는 그 이상의 프로세스가 수행할 수 없는 어떤 특정시간을 기다리고 있는 상태)
	
* Process(프로세스): 메모리에 올라가 구동 중인 프로그램. 프로세스 내에서 실행되는 각각의 일을 쓰레드라 한다.


접근 제한자
------
* pubilc: 접근 제한 없음
* protected: 같은 패키지 내, 다른 패키지에서 상속 받아 자손 클래스에서 접근 가능
* default: 같은 패키지 내에서만 접근 가능
* private: 같은 클래스 내에서만 접근 가능

소켓통신(TCP/UDP)
------
* TCP
	* 연결형 서비스 제공
	* 높은 신뢰성 보장
	* 데이터 흐름 제어, 혼잡 제어
	* 연결 설정 3 way handshaking
	* 연결 해제 4 way handshaking
	
* UDP
	* 비연결형 서비스 제공
	* 신뢰성 낮음
	* 데이터 수신 여부 확인 없음
	* 데이터 전송 순서가 바뀔 수 있음
	* TCP보다 빠른 전송속도

Stack, Queue
------
* STACK
	* LIFO(Last In First Out) 후입선출 구조
	* push();를 이용한 데이터 입력, pop();을 이용한 데이터 출력
	
* QUEUE
	* FIFO(First In First Out) 선입선출 구조
	* Linear Queue(선형큐)는 메모리 재사용이 불가능 이러한 문제점을 보완하여 Circular Queue(원형 큐)가 나옴

Singleton Design Pattern
------
클래스 인스턴스가 하나만 만들어지도록 하고, 그 인스턴스에 대한 전역 접근을 제공한다.

Index (Database)
------
* 인덱스는 데이터베이스 분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료 구조를 일컫는다.
* 인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다.
* 고속의 검색 동작뿐만 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공한다.
* 인덱스를 저장하는 데 필요한 디스크 공간은 보통 테이블을 저장하는 데 필요한 디스크 공간보다 작다.
* 데이터베이스에서 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하고 있는 객체(object)이다. 
* 사용자는 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 인덱스를 생성하고 사용한다. 
* DB에서 자료를 검색하는 두 가지 방법
	* FTS(Full Table Scan) : 테이블을 처음 부터 끝까지 검색하는 방법
	* Index Scan : 인덱스를 검색하여 해당 자료의 테이블을 액세스 하는 방법.
