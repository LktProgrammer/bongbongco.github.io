---
layout: post
title: 시간 복잡도(Time complexity)
categories: [Programming]
tags: [Programming, Algorithm]
fullview: false
comments: true
published: true
use_math: false
---

* 시간 복잡도 : 어떤 알고리즘이 얼마나 걸리는가 (CPU)
* 공간 복잡도 : 어떤 알고리즘이 메모리를 얼마나 쓰는가 (RAM)

**시간 복잡도에 사용되는 수들**

* 1(constant) : 입력자료의 수에 관계 없이 일정한 실행 시간을 갖는 알고리즘
* logN : N이 증가함에 따라 실행식간이 조금씩 늘어나는 경우로 주료 커다란 문제를 일정한 크기를 갖는 작은 문제로 쪼갤 때 나타나는 유형
* N(Linear) : 입력 자료의 수에 따라 선형적으로 실행 시간이 걸리는 경우로 입력 자료 각각에 일정 정도의 동일한 처리를 할때 나타나는 유형
* N logN : 커다란 문제를 독립적인 작은 문제로 쪼개어 각각에 대해 독립적으로 해결하고, 나중에 다시 그것들을 하나로 모으는 경우에 나타난다. N이 두배로 늘어나면 실행 시간은 2배보다 약간 더 많이 늘어난다.
* N^2(quadratic) : 이중루프내에서 입력 자료를 처리하는 경우에 나타난다. N값이 큰값이 되면 실행 시간은 감당할 수 없게 커진다.
* N^3(Cubic) : 입력 자료를 삼중 루프내에서 처리하는 경우에 나타난다.
* 2^n : 입력자료의 수가 늘어남에 따라 급격히 실행 시간이 늘어난다. 

**시간 복잡도 표현법**

* Big O Notation - O(N) : 알고리즘 실행시간의 상한을 나타낸 표기법 (최악)
* 오메가 표기법 : 알고리즘 실행시간의 하한을 나타낸 표기법 (최상)
* 세타 표기법 : 알고리즘 실행시간의 평균시간을 나타낸 표기법 (평균)

**시간 복잡도 계산법**

명령이 끝날때마다 실행 횟수를 적어봅니다.

```
void  Func(int *a, n)
{
     int i=0, j=0;                                       1
     for (i = 0 ; i < n-1 ; i++)                      n      (i =0일때부터 i=n-1일때까지 계속 실행되죠)
         for(j=i+1; j<n ; j++)                        (n-1) * n (가장 많이 수행되는 경우를 생각합니다.)
            if (a[i] == a[j]) a[j] = 0 ;            (n-1) * (n-1)
}
```
 
명령어 실행횟수를 모두 더하면 2n²-2n+2  ->상수는 생략하고 최고차항만 생각한다. => O(n²)로 표기합니다.
 
```
int Func2(int a[], int size, int key)  {
   int i = 0;                                          1
   for (i = 0; i < size; i++)                      size + 1
       if(a[i] == key)                              size
       return i;                                      1
   return -1;                                        1
}
```

시간복잡도 O(size)
총 실행횟수 : 2size +4  => O(N) 
